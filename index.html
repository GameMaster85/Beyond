<html>
	<head>
		<title>Beyond</title>
		<link rel="shortcut icon" href="">
		<style>
			body {
				background-color: black;
				margin: 0 0 0 0;
			}
			div {
				display: block;
				float: left;
				height: auto;
				width: 100%;
				background-color: black;
				color: white;
			}
			div.options{
				height: 100%;
				display: flex;
				flex-direction: column;
			}
			div.charlist{
				flex-grow: 1;
				overflow-y: auto;
				height: calc(100% - 54px);
			}
			div.character span{
				cursor: default;
				-webkit-user-select: none;
				-moz-user-select: none;
				-ms-user-select: none;
				user-select: none;
			}
			div.derivative{
				padding-bottom: 5px;
				height:50px;
				line-height: 50px;
			}
			div.derivative span{
				height:50px;
				width: calc(100% - 50px);
				margin: 0;
				border: 0;
				color: white;
				display: inline-block;
				vertical-align: middle;
				line-height: normal;
			}
			div.action {
				font-weight: bold;
			}
			div.log {
				font-weight: bold;
			}
			div.system {

			}
			div#IO{
				height: 100%;
			}
			div#OOC{
				overflow-y: auto;
			}
			div#IC{
				overflow-y: auto;
			}
			input {
				background-color: black;
				color: white;
				border-color: black;
			}
			input.OOCbar {
				background-color: red;
				color: black;
			}
			input.OOCbar:focus {
				outline-width: 0;
			}
			ul.tab{
			    list-style-type: none;
			    margin: 0;
			    padding: 0;
			    overflow: hidden;
			    background-color: black;	
			}
			ul.tab li {
				transition: 0.3s;
			}
			ul.tab li:hover{background-color: #555;}
			ul.tab li div{
				text-align: center;
				border: 1px solid #333;
				cursor: default;
				font-size: 10pt;
				display: inline-block;
				color: white;
				transition: 0.3s;
				background-color: black;
				-webkit-user-select: none;
				-moz-user-select: none;
				-ms-user-select: none;
				user-select: none;
			}
			ul.tab li div:hover{background-color: #555;}
			.gutter {
				background-color: #d3d3d3;
			}
			.gutter.gutter-horizontal{
				height: 100%;
				cursor: ew-resize;
			}
			.gutter.gutter-vertical{
				cursor: ns-resize;
			}
			.modalContainer{
				z-index: 1;
				position: fixed;
				pointer-events: none;
				background: none;
			}
			.modal {
				pointer-events: auto;
				z-index: 1;
				position: fixed;
				display: none;
				width: auto;
				overflow: auto;
				background-color: rgb(0,0,0);
				background-color: rgba(50,50,50,0.8);
			}
			div.contextMenu{
				z-index: 1000;
				position: fixed;
				width: auto;
			}
			div.contextOption{
				border: 1px solid #333;
				transition: 0.3s;
				padding: 0 5;
				float: none;
				cursor: default;
				width: auto;
				-webkit-user-select: none;
				-moz-user-select: none;
				-ms-user-select: none;
				user-select: none;
			}
			div.contextOption:hover{
				background-color: #555;
			}
		</style>
	</head>
	<body>
		<div id="main"></div>

		<script src="/socket.io/socket.io.js"></script>
		<script src="http://www.myersdaily.org/joseph/javascript/md5.js"></script>
		<script src="http://nathancahill.github.io/Split.js/split.js"></script>
		<script src="https://cdn.rawgit.com/viliusle/Hermite-resize/master/dist/hermite.js"></script>
		<script src="http://www.lalit.org/wordpress/wp-content/uploads/2008/05/fontdetect.js"></script>
		<script src="https://unpkg.com/react@15.3.2/dist/react.js"></script>
		<script src="https://unpkg.com/react-dom@15.3.2/dist/react-dom.js"></script>
		<script src="https://unpkg.com/babel-core@5.8.38/browser.min.js"></script>
		<script type="text/babel">

		var socket = io();

		var Outercontainer = React.createClass({
			getInitialState: function(){
				return {settings: {}, characters: [], modal: [{type: 'login'}], isadmin: false, username: ''};
			},

			componentDidMount: function(){
				var that = this;
				Split(['#left', '#OI'], {
				});
				Split(['#IC', '#OOC'], {
					direction: 'vertical'
				});
				//Admittedly a bit of a cheesey workaround, but Split.js gives me a lot of useful functionality and until it fixes the fact that it sets them to static pixel values when I use sizes: [20, 80] I gotta do it SOMEHOW.
				//If split.js ever breaks on me I'll probably code the sliders based on it instead of dealing with it including that bug, but it isn't worth the effort right now.
				document.getElementById('left').style.width = "calc(25% - 5px)";
				document.getElementById('OI').style.width = "calc(75% - 5px)";
			},

			closeModal: function(n){
				var modal = this.state.modal;
				modal[n] = undefined;
				this.setState({modal: modal});
			},

			handleEnter: function(e){
				if(e.key === 'Enter'){
					//placeholder test function, will be added to the options menu later.
					if(this.refs.OOCbar.value.startsWith("/setcolor ")){
						var set = this.state.settings;
						set.textcolor = this.refs.OOCbar.value.split(" ")[1];
						this.setState({settings: set});
					}
					this.props.socket.emit('OOCmessage', this.refs.OOCbar.value, this.state.settings.textcolor);
					this.refs.OOCbar.value = '';
				}
			},

			handleSettings: function(settings, characters){
				this.setState({settings: settings, characters: characters});
				this.props.socket.emit('save', JSON.stringify({settings: settings, characters: characters}));
			},

			setUser: function(name){
				this.setState({username: name});
			},

			contextMenu: function(e){
				var target = e.target;
				e.preventDefault();
				e.stopPropagation();
				//TODO: see if you can somehow combine the context menus to show all relevant options for a given rightclick and link them properly to their targets.
				var options = target.getAttribute('data');
				while(!options && target.parentNode.getAttribute('id') != 'main'){
					target = target.parentNode;
					options = target.getAttribute('data');
				}
				if(options){
					var position = {x: e.nativeEvent.clientX, y: e.nativeEvent.clientY};
					options = options.split(",");//a list of the option names
					var processed = [];
					var that=this;
					options.forEach(function(option, index){
						var check = option.split('*');
						var ret = check.shift();
						check = check[0];
						if(check){//option has a condition
							if(check == 'admin' && !that.state.isadmin){
								return;//do not add.
							} else if(check != that.state.username){//username check
								return;
							}
						}
						processed.push(ret);
					});
					if(processed.length){
						this.setState({context: {position: position, options: processed, target: target}});
					}
				}
			},

			handleContext: function(e){
				var mod = this.state.modal;
				var name = e.target.textContent;
				var id = this.state.context.target.getAttribute('id').split(',');
				var newmodal = {id: id, name: name};
				if(name.startsWith('Delete')){
					newmodal.type = 'delete';
				} else if(name.endsWith("Character") || name.endsWith("Derivative")){
					newmodal.type = 'character';
				} else if(name.endsWith("Group")){
					newmodal.type = 'group';
				} else if(name.endsWith("Action") || name.endsWith("Say")){
					newmodal.type = 'action';
				} else if(name == 'Edit'){
					newmodal.type = 'action';
					newmodal.post = this.state.context.target.children[2].textContent;
					if(newmodal.post.charAt(0) === '"'){
						newmodal.post = newmodal.post.slice(1, -1);
					}
					if(newmodal.post.endsWith(" (Edited)")){
						newmodal.post = newmodal.post.slice(0, -9);
					}
				}
				this.modalpush(mod, newmodal);
				this.setState({modal: mod});//if mod isn't changed it probably won't even update, and if it does the difference will be irrelevant.
			},

			modalpush: function(mod, data){//helper for putting new modals in.
				var i=0;
				while(mod[i]){//until we find one that's undefined
					i++;
				}//we leave the loop when mod[i] is undefined, so...
				mod[i] = data;
			},

			closeContext: function(e){
				//this function just tells the context menu to close if you click literally anything.
				this.setState({context: null});
			},

			render: function(){//whenever I need bottom space I can tell left and IO to have their height as 100% - (however many pixels)
				var context = <div className='contextMenu' style={{display: 'none'}}></div>;
				if(this.state.context){
					var that = this;
					var options = this.state.context.options.map(function(op, i){
						return(<div key={i} className='contextOption' onClick={that.handleContext}>{op}</div>);
					});
					if(this.state.context.position.y > (0.75*window.innerHeight)){
						context = (<div className='contextMenu' style={{left: this.state.context.position.x+'px', bottom:(window.innerHeight-this.state.context.position.y)+'px'}}>{options}</div>);
					} else {
						context = (<div className='contextMenu' style={{left: this.state.context.position.x+'px', top:this.state.context.position.y+'px'}}>{options}</div>);
					}
				}

				return (
					<div style={{height: "calc(100% - 15px)"}} onContextMenu={this.contextMenu} onClick={this.closeContext}>
						<ModalHandler socket={this.props.socket} handleSettings={this.handleSettings} setUser={this.setUser} modal={this.state.modal} closeModal={this.closeModal} characters={this.state.characters} settings={this.state.settings}/>
						{context}
						<div id="left">
							<ChartabHandler socket={this.props.socket} handleSettings={this.handleSettings} characters={this.state.characters}/>
						</div>
						<div id="OI">
							<div id="IC">
								<IChandler socket={this.props.socket}/>
							</div>
							<div id="OOC">
								<OOChandler socket={this.props.socket}/>
							</div>
						</div>
						<input className="OOCbar" style={{width: '100%', padding: '0 0 0 0', border: '0'}} type="text" ref="OOCbar" placeholder="Input an OOC message" onKeyPress={this.handleEnter}/>
					</div>
				);
			}
		});

		var ModalHandler = React.createClass({
			getInitialState: function(){
				return {positions: [], currentDrag: null, loginmessage: 'Please input a username and password of at least 6 characters.'};
			},

			submission: function (e){
				var type = e.target.getAttribute('id');
				e.preventDefault();
				var that=this;
				var username = this.refs.username.value;
				var password = this.refs.password.value;
				if(username.length >= 6 && password.length >= 6){
					var ind = e.target.parentNode.getAttribute('id');
					this.props.socket.emit(type, username, md5(password), function (response){
						if(response.settings){
							that.props.handleSettings(response.settings, response.characters);
							that.props.setUser(username);
							that.props.closeModal(ind);
						} else {
							that.setState({loginmessage: response.code || response});
						}
					});
				}
			},

			startDrag: function(e){
				if(e.target.getAttribute('class') == "modal"){//only START for the modal containers.
					e.stopPropagation();
					e.preventDefault();
					this.setState({currentDrag: e.target.getAttribute('id'), initialposition: {x: e.nativeEvent.offsetX, y: e.nativeEvent.offsetY}});
					document.addEventListener('mousemove', this.drag);
					document.addEventListener('mouseup', this.stopDrag);
				}
			},

			drag: function(e){
				e.stopPropagation();
				e.preventDefault();
				var pos = this.state.positions;
				var initpos = this.state.initialposition;
				pos[this.state.currentDrag] = {x: e.clientX-initpos.x, y: e.clientY-initpos.y};
				this.setState({positions: pos});
			},

			stopDrag: function(e){
				e.stopPropagation();
				e.preventDefault();
				this.setState({currentDrag: null});
				document.removeEventListener('mousemove', this.drag);
				document.removeEventListener('mouseup', this.stopDrag);
			},

			handleFIs: function(e){
				var list = e.target.files;
				var id = e.target.parentNode.getAttribute('id');//current index
				/*var canvas = this.refs['canvas'+e.target.parentNode.getAttribute('id')];
				var ctx = canvas.getContext('2d');*/
				var img = [];
				for(var i=0; i<list.length; i++){
					if (list[i].type.match(/image.*/)) {
						img.push(window.URL.createObjectURL(list[i]));
					};
				}
				var images = this.state.images || [];
				images[id] = img;
				this.setState({images: images});
			},

			enterCheck: function(e){
				if(e.keyCode == 13 && !e.shiftKey){//hit enter
					this.post(e);
				}
			},

			post: function(e){
				var modal = e.target.parentNode;
				var id = modal.getAttribute('id');
				var modata = this.props.modal[id];
				var post = this.refs['text'+id].value;
				if(post){
					if(modata.name == 'Edit'){
						if(modata.post != post){
							this.props.socket.emit('ICedit', post, modata.id[0]);
						}
					} else {
						var deriv = this.props.characters[modata.id[0]][modata.id[1]][modata.id[2]];
						this.props.socket.emit('characterPost', post, deriv, modata.name);
					}					
				}

				this.props.closeModal(id);
			},

			testFont: function(e){
				try{
					var d = new Detector();
					if(!e.target.value){
						e.target.style['outline-color'] = '#777'
					} else {
						if(d.detect(e.target.value)){
							e.target.style['outline-color'] = '#0f0';
							e.target.style.fontFamily = e.target.value;
						} else {
							e.target.style['outline-color'] = '#f00';
						}
					}
				} catch(err){
					e.target.style['outline-color'] = '#777';
				}
			},

			fontTest: function(e){
				if(e.ctrlKey && e.keyCode == 66){
					if(e.target.style.fontWeight == 'bold'){
						e.target.style.fontWeight = 'normal';
					} else {
						e.target.style.fontWeight = 'bold';
					}
					
				}
			},

			closeChar: function(id){
				var images = this.state.images;
				if(images){
					images[id] = null;
					this.setState({images: images});
				}
				this.props.closeModal(id);
			},

			charDelete: function(e){
				var modal = e.target.parentNode;
				var id = modal.getAttribute('id');
				var modata = this.props.modal[id];
				//modata.id contains the ids involved.
				var characters = this.props.characters;
				if(modata.id.length === 1){//group delete
					//TODO: Make sure this works after making group options.
					var salvage = characters.splice(modata.id[0], 1);
					characters[0].push(salvage);//add the characters to the ungrouped section.
				} else if(modata.id.length === 2 || characters[modata.id[0]][modata.id[1]].length == 1){//character delete
					characters[modata.id[0]].splice(modata.id[1], 1);
				} else {
					characters[modata.id[0]][modata.id[1]].splice(modata.id[2], 1);
				}
				this.props.handleSettings(this.props.settings, characters);
				this.props.closeModal(id);
			},

			charEdit: function(e){
				var modal = e.target.parentNode;//the modal containing the save button
				var id = modal.getAttribute('id');//I'll be using this frequently, so I'd best.
				var name = this.refs['name'+id].value;
				var icons = this.refs['faceicons'+id].children;
				if(name || this.props.modal[id].id.length > 1){//do nothing if they didn't put a name in if it's new
					var fontStyle = this.refs['font'+id].value;
					var nameColor = this.refs['nameColor'+id].value;
					var color = this.refs['color'+id].value;
					var canvas = this.refs['canvas'+id];
					//canvas.width=50; canvas.height=50;
					var ctx = canvas.getContext('2d');
					var convertedicons = [];
					var hermi = true;
					try{
						var hermite = new Hermite_class();
					} catch(err){
						hermi = false;
					}
					for(var i=0; i < icons.length; i++){
						if(hermi){
							var h = icons[i].naturalHeight;
							var w = icons[i].naturalWidth;
							canvas.width = w; canvas.height=h;
							ctx.drawImage(icons[i], 0, 0);
							hermite.resample_single(canvas, 50, 50, true);					
						} else {
							ctx.drawImage(icons[i], 0, 0, 50, 50);
						}
						convertedicons.push(canvas.toDataURL("image/png"));
					}
					var that=this;

					this.props.socket.emit('sendimage', convertedicons, function(response, un){
						var modata = that.props.modal[id];
						var settings = that.props.settings;
						var characters = that.props.characters;
						var character;
						if(modata.id.length === 1){//new char only
							modata.id.push(characters[modata.id[0]].length);//put it at the end of the group
							character = [];
						} else {//i1 is group, i2 is character
							character = characters[modata.id[0]][modata.id[1]];
						}
						if(modata.id[2]){//only in the edit case (we have a deriv) do we NOT add.
							var deriv = character[modata.id[2]];
							character[modata.id[2]] = {id: deriv.id, name: name || deriv.name, icon: response[0] || deriv.icon, nameColor: nameColor, color: color, fontStyle: fontStyle || deriv.fontStyle};
						} else {//but in the add derivatives case we use the 0-ID.
							var charid = character[0] ? character[0].id : un+'-'+settings.characterIDs++;
							for(i=0; i<response.length; i++){
								character.push({id: charid, name: name || character[0].name, icon: response[i], nameColor: nameColor, color: color, fontStyle: fontStyle});
							}

						}//now we've added all the new derivatives or just modified the one.
						characters[modata.id[0]][modata.id[1]] = character;//adds new if new, otherwise overwrites
						that.props.handleSettings(settings, characters);
						that.closeChar(id);
					});
				}
				
			},

			render: function(){
				var that = this;
				var modals=this.props.modal.map(function (modal, index){
					if(modal){
						var x = '25%';
						var y = '25%';
						if(that.state.positions[index]){
							x = that.state.positions[index].x+'px';
							y = that.state.positions[index].y+'px';
						}
						switch(modal.type){
							case 'login'://basically hardcoded and single-purpose.
								return(
									<div key={index} id={index} ref={index} className="modal" style={{display: 'block', left: x, top: y}} onMouseDown={that.startDrag}>
										<input type="text" name="username" ref="username" placeholder="Username" required /><br/>
										<input type="text" name="password" ref="password" placeholder="Password" required /><br/>
										<button type="submit" id="login" onClick={that.submission}>Login</button>
										<button type="submit" id="register" onClick={that.submission}>Register</button><br/>
										<b>{that.state.loginmessage}</b>
									</div>);
							case 'character'://character creation/edit modal.
								var groupdropdown = null;
								var FIs = (<input type='file' ref={'FIs'+index} multiple onChange={that.handleFIs}/>);//by default it allows multiple
								var nameColor; var color; var fontStyle;
								var character;
								if(modal.id.length == 1){//new character
									nameColor = '#ffffff';
									color = '#ffffff';
									fontStyle = 'Times New Roman';
									groupdropdown = null;//TODO: Implement dropdown
								} else {
									character = that.props.characters[modal.id[0]][modal.id[1]];
									nameColor = character[0].nameColor;
									color = character[0].color;
									fontStyle = character[0].fontStyle;
								}
								if(modal.id.length == 3){//only one FI allowed, as it's editing one derivative
									FIs = <input type='file' ref={'FIs'+index} onChange={that.handleFIs}/>;
									color = character[modal.id[2]].color || color;
									nameColor = character[modal.id[2]].nameColor || nameColor;
									fontStyle = character[modal.id[2]].fontStyle || fontStyle;
								}
								var previews = null;
								var im = that.state.images;
								if(im && im[index]){
									previews = im[index].map(function(img, index){
										return(<img src={img} key={index} width='50px' height='50px'/>);
									});
								}
								return(
									<div key={index} id={index} ref={index} className="modal" style={{display: 'block', left: x, top: y}} onMouseDown={that.startDrag}>{FIs}<br/>
									<span ref={'faceicons'+index}>{previews}</span><canvas ref={'canvas'+index} width='0' height='0'></canvas><br/>
									<input type="text" ref={'name'+index} placeholder="Character Name" required/><br/>
									Name Color: <input type="color" ref={'nameColor'+index} defaultValue={nameColor}/><br/>
									Text Color: <input type="color" ref={'color'+index} defaultValue={color}/><br/>
									<input type="text" ref={'font'+index} placeholder="Font Style" defaultValue={fontStyle} style={{fontFamily: fontStyle}} onChange={that.testFont} onKeyDown={that.fontTest}/><br/>
									{groupdropdown}<br/>
									<button type="submit" id="save" onClick={that.charEdit}>Save</button>
										<button type="submit" id="cancel" onClick={that.closeChar.bind(null, index)}>Cancel</button></div>
								);
							case 'group'://group creation/edit modal.
								break;
							case 'delete'://'are you sure?'
								return(
									<div key={index} id={index} ref={index} className="modal" style={{display: 'block', left: x, top: y}} onMouseDown={that.startDrag}>Are you sure?<br/><button type="submit" onClick={that.charDelete}>Yes</button><button type="submit" onClick={that.props.closeModal.bind(null, index)}>No</button></div>
								);
							case 'action':
								return(
									<div key={index} id={index} ref={index} className="modal" style={{display: 'block', left: x, top: y}} onMouseDown={that.startDrag}><textarea defaultValue={modal.post || ''} autoFocus rows='4' cols='40' ref={'text'+index} onKeyDown={that.enterCheck}></textarea><br/><button type="submit" onClick={that.post}>OK</button><button type="submit" onClick={that.props.closeModal.bind(null, index)}>Cancel</button></div>
								);
						}
					} else {
						return(<div key={index} className="modal" style={{display:'none'}}></div>);
					}
				});
				return (
					<div className="modalContainer" style={{width:'100%', height:'100%'}}>{modals}</div>
				);
			}
		});

		var ChartabHandler = React.createClass({
			getInitialState: function(){//open.characters[ID] will be true if we need to open derivs
				return {tab: 'Characters', open:{groups: {}, characters: {}}};
			},

			shiftTab: function(e){//It's both a relevant name and a terrible pun!
				this.setState({tab: e.target.getAttribute('id')});
			},


			openGroup: function(e){
				var op = this.state.open;
				var name = this.props.characters[e.target.getAttribute('id')].name;
				op.groups[name] = true;//add group to open list
				this.setState({open: op});
			},

			closeGroup: function(e){
				var op = this.state.open;
				var name = this.props.characters[e.target.getAttribute('id')].name;
				op.groups[name] = false;
				this.setState({open: op});
			},

			openChar: function(e){
				var id = e.target.getAttribute('id').split(',');
				var op = this.state.open;
				var name = this.props.characters[id[0]][id[1]][0].id;//characters[0][2][0] for instance.
				op.characters[name] = true;
				this.setState({open: op});
			},

			closeChar: function(e){
				var id = e.target.getAttribute('id').split(',');
				var op = this.state.open;
				var name = this.props.characters[id[0]][id[1]][0].id;
				op.characters[name] = false;
				this.setState({open: op});
			},

			render: function(){
				var currenttab = null;
				var that=this;
				switch(this.state.tab){//use this to acquire the jsx for each tab
					case 'characters'://case for the characters tab
						//TODO: Consider making the [+] and [-] float right or something.
						var characters = this.props.characters;
						var charlist = characters.map(function(group, i){//groups loop
							if(i==0 || that.state.open.groups[group.name]){//open group
								var chars = characters[i].map(function(chr, i2){//characters loop
									//contemplate making character headers like group headers and only showing the derivatives as individual.
									if(that.state.open.characters[chr[0].id]){//open derivative list
										var derivs = characters[i][i2].map(function(deriv, i3){
											return(<div data={['Edit Derivative', 'Delete Derivative', 'Say', 'Action', 'Omit Say', 'Omit Action', 'Test Say', 'Test Action']} key={i3} id={i+','+i2+','+i3} className="derivative"><img src={'/faceicons/'+deriv.icon+'.png'}/><span>{deriv.name}</span></div>);
										});
										return(<div data={['Create Derivative', 'Delete Character']} key={i2} id={i+','+i2} className="character"><span id={i+','+i2} onClick={that.closeChar}>{chr[0].name} [-]</span>{derivs}</div>);
									} else {//closed derivative list
										return(<div data={['Create Derivative', 'Delete Character']} key={i2} id={i+','+i2} className="character"><span id={i+','+i2} onClick={that.openChar}>{chr[0].name} [+]</span></div>);
									}
								});
								if(group.name){//actual group
									return(<div data={['New Character', 'Edit Group', 'Delete Group']} key={i} id={i} className="chargroup"><span id={i} onClick={that.closeGroup}>{group.name} [-]</span>{chars}</div>);
								} else {//ungrouped
									return(<div id={0} data={['New Character', 'New Group']} key={i} className="chargroup ungrouped">{chars}</div>);
								}
							} else {//closed group
								return(<div data={['New Character', 'Edit Group', 'Delete Group']} key={i} id={i} className="chargroup"><span id={i} onClick={that.openGroup}>{group.name} [+]</span></div>);
							}
						});
						currenttab = (<div id={0} data={['New Character', 'New Group']} className="charlist">
							{charlist}
							</div>);
						break;
					case 'players'://case for the players online tab
						break;
					case 'commands'://case for player commands tab
						break;
					case 'admin'://case for the administrative commands tab
						break;
					case 'server'://case for server control tab
						break;
				}

				return (
					<div className="options">
						<ul className="tab" style={{listStyleType:'none'}}>
							<li><div className="tablink" id="characters" onClick={this.shiftTab}>Characters</div></li>
							<li><div className="tablink" id="players" onClick={this.shiftTab}>Players Online</div></li>
							<li><div className="tablink" id="commands" onClick={this.shiftTab}>Player Commands</div></li>
						</ul>
						{currenttab}
					</div>
				);
			}
		});

		var Message = React.createClass({

			htmlupdate: function(){//modify content to innerHTML
				var message = this.props.message;
				var classparam = message.className.split(" ")[1];
				var post = message.post;
				if(this.refs.post){
					switch(classparam){
						case 'say':
							post = '"'+post+'"';
							if(message.className.startsWith('O')){//omit
								post += ' <b>(Omit)</b>';
							}
							break;
						case 'action':
							if(message.className.startsWith('O')){//omit
								post += ' (Omit)';
							}
							break;
					}
					this.refs.post.innerHTML = post;
				}
			},

			componentDidMount: function(){
				this.htmlupdate();
			},

			componentDidUpdate: function(){
				this.htmlupdate();
			},

			render: function(){
				var message = this.props.message;
				var character = message.character;//worst case it's just null and then it won't be getting used anyway.
				var classparam = message.className.split(" ")[1];
				switch(classparam){
					case 'message'://ooc message
						return (<div className={message.className}>( <b>{message.username+': '}</b><span ref="post" style={{color: message.color}}></span> )</div>);
					case 'log':
						return (<div className={message.className}>{"| "+message.username+" "+message.post+" |"}</div>);
					case 'say':
						if(message.className.startsWith('O')){//omit
							return(<div className={message.className} style={{fontFamily: character.fontStyle}}><img src={'/faceicons/'+character.icon+'.png'}/><span style={{fontWeight: 'bold', color: character.nameColor}}>{character.name+': '}</span><span ref="post" style={{color: character.color}}></span></div>);
						} else {
							var charid = character.id.split('-');
							charid.pop();
							charid = charid.join('-');//catches names with - in them
							return(<div id={message.id} data={'Edit*'+charid} className={message.className} style={{fontFamily: character.fontStyle}}><img src={'/faceicons/'+character.icon+'.png'}/><span style={{fontWeight: 'bold', color: character.nameColor}}>{character.name+': '}</span><span ref="post" style={{color: character.color}}></span></div>);
						}
					case 'action':
						if(message.className.startsWith('O')){//omit
							return(<div className={message.className} style={{fontFamily: character.fontStyle}}><img src={'/faceicons/'+character.icon+'.png'}/><span style={{color: character.nameColor}}>{character.name+' '}</span><span ref="post" style={{color: character.color}}></span></div>);
						} else {
							var charid = character.id.split('-');
							charid.pop();
							charid = charid.join('-');//catches names with - in them
							return(<div id={message.id} data={'Edit*'+charid} className={message.className} style={{fontFamily: character.fontStyle}}><img src={'/faceicons/'+character.icon+'.png'}/><span style={{color: character.nameColor}}>{character.name+' '}</span><span ref="post" style={{color: character.color}}></span></div>);
						}
				}
			}
		});

		var IChandler = React.createClass({
			getInitialState: function(){
				//normally messages would be empty but I want to test this out.
				return {messages: [], ids: {}};
			},

			componentDidMount: function(){
				var that = this;
				this.props.socket.on('ICmessage', function(message){
					var newm = that.state.messages.slice();
					var ids = that.state.ids;
					ids[message.id] = newm.length;//index this post to its id
					newm.push(<Message key={newm.length} message={message}/>);
					that.setState({messages: newm, ids: ids});
				});

				this.props.socket.on('ICedit', function(message){
					var messages = that.state.messages.slice();
					var ids = that.state.ids;
					var target = messages[ids[message.id]];
					if(target){//if it isn't in here obviously we aren't doing it.
						var msg = target.props.message;
						msg.post = message.post;
						messages[ids[message.id]] = React.cloneElement(target, msg);
						
						that.setState({messages: messages});
					}
				});
			},

			render: function(){
				return (
					<div className='ICbox'>
						{this.state.messages}
					</div>
				);
			}
		});

		var OOChandler = React.createClass({
			getInitialState: function(){
				return {messages: []};
			},

			componentDidMount: function(){
				var that = this;
				this.props.socket.on('OOCmessage', function(message){
					var newm = that.state.messages.slice();
					newm.push(<Message key={newm.length} message={message}/>);
					that.setState({messages: newm});
				});				
			},

			render: function(){
				return (
					<div className='OOCbox'>
						{this.state.messages}
					</div>
				);
			}
		});

		ReactDOM.render(
			<Outercontainer socket={socket}/>,
			document.getElementById('main')
		);
		</script>
	</body>
</html>